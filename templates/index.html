{% extends "d3-base.html" %}

{% block head %}
<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="/static/js/dagre.min.js"></script>
<script src="/static/js/dagre-d3.min.js"></script>
<link rel="stylesheet" type="text/css" href="/static/css/index.css">

<style id="css">
    .node rect {
      stroke: #333;
      fill: #fff;
      stroke-width: 1px;
    }
    
    .edgePath path {
      stroke: #333;
      fill: #333;
      stroke-width: 1.5px;
    }
</style>
{% endblock %}

{% block body %}
<div id="graph">
    <!-- container where graph will be rendered -->
    <svg width="960" height="600"><g/></svg>

    <section>
        <p>Potomac AI Inc.</p>
    </section>
</div>

<script type="">
    // import json data for the graph structure from FastAPI
    var graph_data = {{ json_data | tojson | safe }};
    var nodes = graph_data.nodes;
    var edges = graph_data.edges;
</script>

<script>
    // Create a new directed graph 
    var g = new dagre.graphlib.Graph({ directed: true, compound: false, multigraph: false });

    // Set an object for the graph label
    g.setGraph({});

    // Add nodes to the graph. 
    // Note: the order of when the nodes are declared does not determine the layout of the graph.
    nodes.forEach(function(node) {
        g.setNode(
            node.id, 
            { 
                label: node.label, 
                width: node.width, 
                height: node.height, 
                endpoint: node.endpoint,
                progress_endpoint: node.progress_endpoint
            }
        );
    });

    // Add edges to the graph.
    edges.forEach(function(edge) {
        g.setEdge(edge.source, edge.target, { arrowhead: "vee" });
    });

    var svg = d3.select("svg");
    var inner = svg.select("g");

    // Set up zoom support
    function zoomed(event) {
        inner.attr("transform", event.transform);
    }
    svg.call(d3.zoom().on("zoom", zoomed));

    // Create the renderer
    var render = new dagreD3.render();

    // Run the renderer. This is what draws the final graph.
    render(inner, g);

    // select node containers
    const node_container = inner.selectAll(".node");

    // apply HTMX attributes to the entire node container
    // in the future, we will use the endpoint attribute to determine the endpoint for the HTMX request
    node_container.attr("hx-get", (v) => { return g.node(v).endpoint; })
                  .attr("hx-trigger", "click")
                  .attr("hx-target", "#graph")
                  .attr("hx-swap", "outerHTML");
    
    // apply SVG attributes to the rect element
    const rect = inner.selectAll("rect");
    rect.attr("rx", 10);
    rect.attr("ry", 10);

    const text = inner.selectAll(".node .label g text");
    text.append("tspan")
        .text("0%")
        .attr("space", "preserve")
        .attr("dy", "1em")
        .attr("x", "1")
        .attr("hx-get", (v) => { return g.node(v).progress_endpoint; })
        .attr("hx-target", "this")
        .attr("hx-trigger", "every 1s")
        .attr("hx-swap", "innerHTML");

</script>
{% endblock %}